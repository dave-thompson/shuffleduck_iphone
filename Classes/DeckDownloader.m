//
//  DeckDownloader.m
//  MindEgg
//
//
//  Created by Dave Thompson on 1/11/10.
//  Copyright 2010 __MyCompanyName__. All rights reserved.
//

#import "DeckDownloader.h"
#import "DDXML.h"
#import "ASIHTTPRequest.h"
#import "VariableStore.h"
#import "MyDecksViewController.h"
#import "ProgressViewController.h"
#import "Constants.h"
#import "DeckDownloaderQueueItem.h"

static DeckDownloader *sharedDeckDownloader = nil;
static NSMutableArray *downloadQueue;
static BOOL locked;
static BOOL fullDeckFailureFlag = NO;
static BOOL isAResumeRequestAndNotYetReachedShuffleDuck = NO;
@implementation DeckDownloader

BOOL inCardsDefinition; // is XML parser currently looking at cards (rather than template)

// variable to store the text within current element
NSString *currentText = @"";

// variables to store current attributes
NSString *text;
int fontID;
CGFloat fontSize;
CGFloat foregroundAlpha, backgroundAlpha;
int foregroundColor, backgroundColor;
int alignmentID;
int backgroundTransparent; // bool value represented as an int for sqlite compatibility

// variables to store last autogenerated ID
int deckID;
int cardID;
int sideID;
int componentID;

// variables to store the number of sister nodes thus far encountered
int currentCardPosition;
int currentSidePosition;
int currentComponentPosition;

// debugging variables
NSDate *startTime;

sqlite3_stmt *addStmt;

#pragma mark -
#pragma mark Singleton Accessor

+ (DeckDownloader *)sharedInstance
{
	@synchronized(self)
	{
		if (!sharedDeckDownloader)
		{
			sharedDeckDownloader = [[[self class] alloc] init];
			downloadQueue = [[NSMutableArray alloc] initWithCapacity:1];
			locked = NO;
		}
	}
    return sharedDeckDownloader;
}

#pragma mark -
#pragma mark State Reporting

+ (BOOL)downloadIsInProgress
{
	return locked;
}

+ (BOOL)areBrokenDownloads
{
	int result;
	// Find any broken downloads in the DB
	const char *sqlStatement = "SELECT COUNT(*) FROM Deck WHERE fully_downloaded = 0;";
	sqlite3_stmt *compiledStatement;
	if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sqlStatement, -1, &compiledStatement, NULL) == SQLITE_OK)
	{
		while(sqlite3_step(compiledStatement) == SQLITE_ROW)
		{
			result = (int)sqlite3_column_int(compiledStatement, 0);
		}
	}
	
	if (result > 0)
		{return YES;}
	else
		{return NO;}
}

#pragma mark -
#pragma mark Top Level Download Request Methods

-(void)downloadDeckID:(int)userVisibleID
{
	// If the DeckDownloader is already busy, then queue this request. Otherwise, download it.
	if (locked)
	{
		DeckDownloaderQueueItem *queueItem = [[DeckDownloaderQueueItem alloc] initWithUserVisibleID:userVisibleID];
		[downloadQueue addObject:queueItem];
	}
	else
	{
		locked = YES;
		[ProgressViewController startShowingProgress];
		[[MyDecksViewController sharedInstance] showMessage:@"Connecting to ShuttleDuck"];
		
		// retrieve deck metadata
		[self sendMetadataRequestForUserVisibleDeckID:userVisibleID];
	}
}

-(void)completeDownloadOfDeckID:(int)userVisibleID withIPhoneDeckID:(int)deckID
{
	// If the DeckDownloader is already busy, then queue this request. Otherwise, download it.
	if (locked)
	{
		DeckDownloaderQueueItem *queueItem = [[DeckDownloaderQueueItem alloc] initWithUserVisibleID:userVisibleID iPhoneSpecificID:deckID];
		[downloadQueue addObject:queueItem];
	}
	else
	{
		locked = YES;
		
		// retrieve deck
		[self sendFullDeckRequestForUserVisibleDeckID:userVisibleID iPhoneDeckID:deckID];		
	}
}

-(void)resumeBrokenDownloadswithUserRequested:(BOOL)userRequested
{
	if (userRequested)
	{
		isAResumeRequestAndNotYetReachedShuffleDuck = YES;
		[[MyDecksViewController sharedInstance] showMessage:@"Connecting to ShuffleDuck"];
	}
	else
	{
		[[MyDecksViewController sharedInstance] showMessage:@"Resuming partial downloads"];
	}
	
	[ProgressViewController startShowingProgress];
		
	NSMutableArray *brokenDecks = [[NSMutableArray alloc] initWithCapacity:5];
	
	// Find any broken downloads in the DB
	const char *sqlStatement = "SELECT Deck.id, Deck.user_visible_id FROM Deck WHERE fully_downloaded = 0 ORDER BY Deck.position;";
	sqlite3_stmt *compiledStatement;
	if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sqlStatement, -1, &compiledStatement, NULL) == SQLITE_OK)
	{
		while(sqlite3_step(compiledStatement) == SQLITE_ROW)
		{
			int brokenDeckID = (int)sqlite3_column_int(compiledStatement, 0);
			int brokenUserVisibleID = (int)sqlite3_column_int(compiledStatement, 1);

			[brokenDecks addObject:[NSArray arrayWithObjects: [NSNumber numberWithInt:brokenDeckID], [NSNumber numberWithInt:brokenUserVisibleID]]];
		}
	}

	// loop through the broken decks in the DB
	for (NSArray *brokenDeck in brokenDecks)
	{
		// delete any remnants
		[self cleanPartiallyDownloadedDeckInDBUsingDeckID:[[brokenDeck objectAtIndex:0] intValue]];
		
		// start downloading the full deck
		[[DeckDownloader sharedInstance] completeDownloadOfDeckID:[[brokenDeck objectAtIndex:1] intValue] withIPhoneDeckID:[[brokenDeck objectAtIndex:0] intValue]];
	}
	
	// Release the compiled statement from memory
	sqlite3_finalize(compiledStatement);
	[brokenDecks release];
}

#pragma mark -
#pragma mark Metadata Request Methods

-(void)sendMetadataRequestForUserVisibleDeckID:(int)aUserVisibleID
{
	NSURL *url = [NSURL URLWithString:[CONTEXT_URL stringByAppendingString:[NSString stringWithFormat:@"/decks/%d", aUserVisibleID]]];
	ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];
	[request setUserInfo:[NSDictionary dictionaryWithObjectsAndKeys:[NSString stringWithFormat:@"%d", aUserVisibleID], @"userVisibleID", nil]];
	[request setDelegate:self];
	[request setDidFinishSelector:@selector(metadataRequestFinished:)];
	[request setDidFailSelector:@selector(metadataRequestFailed:)];
	[request startAsynchronous];	
}

- (void) metadataRequestFinished:(ASIHTTPRequest *)request
{
	// instantiate variables
	DDXMLDocument *doc;
	NSString *responseString = [request responseString];
	doc = [[DDXMLDocument alloc] initWithXMLString:responseString options:0 error:nil];
	if (doc == nil) {[doc release]; return;}
	
	DDXMLElement *rootElement = [doc rootElement];
	if ([XML_ERROR_TAG isEqualToString:[rootElement name]]) // if the server returned an error, abort and tell the user
	{
		// tell the user
		NSString *errorDescription = [[[rootElement elementsForName:@"description"] objectAtIndex:0] stringValue];
		UIAlertView *errorAlert = [[UIAlertView alloc] initWithTitle:[ERROR_DIALOG_TITLE copy] message:errorDescription delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil];
		[errorAlert show];
		
		// finish up
		[self completeDownloadAfterSuccess:NO];
	}
	else // the server returned the deck summary information, so process this and then ask for the full deck
	{
		NSString *deckTitle = [[[rootElement elementsForName:@"title"] objectAtIndex:0] stringValue];
		NSString *author = [[[rootElement elementsForName:@"author"] objectAtIndex:0] stringValue];
		int userVisibleID = [[[[[doc rootElement] elementsForName:@"user_visible_id"] objectAtIndex:0] stringValue] integerValue];
		
		// insert a Deck row into the db to represent the incoming deck. Store the iPhone specific deckID.
		int iPhoneDeckID = [DeckDownloader insertNewDeckMetadataToDBWithUserVisibleID:userVisibleID title:deckTitle author:author];
		
		// download the full list of cards for this deck
		[self sendFullDeckRequestForUserVisibleDeckID:userVisibleID iPhoneDeckID:iPhoneDeckID];
	}
	// clean up
	[doc release];
}

+ (int)insertNewDeckMetadataToDBWithUserVisibleID:(int)aUserVisibleID title:(NSString *)aTitle author:(NSString *)anAuthor
{
	int returnedID;
	
	// first, increment the positions of all existing Decks to move them down the list
	// write value to database
	sqlite3_stmt *stmt = nil;
	if(stmt == nil)
	{
		const char *updateSQL = "UPDATE Deck SET position  = position + 1";
		if(sqlite3_prepare_v2([VariableStore sharedInstance].database, updateSQL, -1, &stmt, NULL) != SQLITE_OK)
			NSLog(@"Error while creating update statement: '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
	}
	else
	{
		NSLog(@"Error: stmt not nil");
	}
	
	if(SQLITE_DONE != sqlite3_step(stmt))
	{NSAssert1(0, @"Error while incrementing DB positions: '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));}
	sqlite3_reset(stmt);
	stmt = nil;
	
	// now can actually insert the Deck row
	const char *sql = "INSERT INTO Deck(title, position, shuffled, user_visible_id, author, fully_downloaded) VALUES(?,?,?,?,?,?)";
	if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sql, -1, &stmt, NULL) != SQLITE_OK)
	{
		NSLog(@"Error while creating Deck INSERT statement: '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
	}
	sqlite3_bind_text(stmt, 1, [aTitle UTF8String], -1, SQLITE_TRANSIENT);
	sqlite3_bind_int(stmt, 2, 1); // position should always be 1 (i.e. at top of list)
	sqlite3_bind_int(stmt, 3, 0); // deck is initially unshuffled
	sqlite3_bind_int(stmt, 4, aUserVisibleID);
	sqlite3_bind_text(stmt, 5, [anAuthor UTF8String], -1, SQLITE_TRANSIENT);
	sqlite3_bind_int(stmt, 6, 0); // deck is not yet fully downloaded
	
	if(SQLITE_DONE != sqlite3_step(stmt))
	{
		NSLog(@"Error running Deck INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
	}
	else
	{
		// store the autoincremented primary key to reference from future inserts
		returnedID = sqlite3_last_insert_rowid([VariableStore sharedInstance].database);
	}
	stmt = nil;
	
	// refresh the decks table to include the new deck
	[[MyDecksViewController sharedInstance] refreshTable];
	
	// return the newly generated iPhone specific Deck ID
	return returnedID;
}

- (void)metadataRequestFailed:(ASIHTTPRequest *)request
{
	// What deck does this failure correspond to?
	// int userVisibleID = [[request.userInfo valueForKey:@"userVisibleID"] integerValue];
	
	// tell user that there was a problem and their deck is not being downloaded
 	UIAlertView *errorAlert = [[UIAlertView alloc]
							   initWithTitle:  [NSString stringWithFormat:@"Couldn't reach ShuffleDuck"]
							   message: [NSString stringWithFormat:@"Please check your network connection and try again."]
							   delegate: nil
							   cancelButtonTitle: @"OK"
							   otherButtonTitles: nil];
	
	[errorAlert show];
	[errorAlert release];
	
	// finish up
	[self completeDownloadAfterSuccess:NO];
}


#pragma mark -
#pragma mark Full Deck Request Methods

-(void)sendFullDeckRequestForUserVisibleDeckID:(int)aUserVisibleID iPhoneDeckID:(int)anIphoneDeckID
{
	[[MyDecksViewController sharedInstance] showMessage:@"Downloading cards  "];
	
	// store iPhone Deck ID for use by remainder of download process
	deckID = anIphoneDeckID;
	
	// ask server to send over full deck details
	NSURL *url = [NSURL URLWithString:[CONTEXT_URL stringByAppendingString:[NSString stringWithFormat:@"/decks/%d/deck_details/1", aUserVisibleID]]];
	ASIHTTPRequest *fullDeckRequest = [ASIHTTPRequest requestWithURL:url];
	[fullDeckRequest setDelegate:self];
	[fullDeckRequest setDidFinishSelector:@selector(fullDeckRequestFinished:)];
	[fullDeckRequest setDidFailSelector:@selector(fullDeckRequestFailed:)];
	fullDeckRequest.userInfo = [[NSDictionary alloc] initWithObjectsAndKeys:
								[NSString stringWithFormat:@"%d", aUserVisibleID], @"userVisibleID",
								nil];
	[fullDeckRequest startAsynchronous];
}

- (void) fullDeckRequestFinished:(ASIHTTPRequest *)request
{
	// instantiate variables
	DDXMLDocument *doc;
	
	// get XML response
	NSString *responseString = [request responseString];
	NSLog(responseString);
	
	// create document, ready to parse XML response
	doc = [[DDXMLDocument alloc] initWithXMLString:responseString options:0 error:nil];
	if (doc == nil) // if something went wrong, clean up
	{
		[doc release];
		return;
	}
	
	// populate database based on retrieved xml_string
	NSString *xmlString = [[[[doc rootElement] elementsForName:@"xml_string"] objectAtIndex:0] stringValue];
	[self parseXMLDeck:xmlString];
	
	// clean up
	[doc release];
}

- (void) fullDeckRequestFailed:(ASIHTTPRequest *)request
{
	// log failure so that user may be notified of it after end of current sync / download
	fullDeckFailureFlag = YES;
	
	// finish up
	[self completeDownloadAfterSuccess:NO];
}

#pragma mark -
#pragma mark Parsing Methods

- (void) parseXMLDeck:(NSString *)xmlString
{
	startTime = [NSDate date];
	NSXMLParser *parser = [[NSXMLParser alloc] initWithData:[xmlString dataUsingEncoding:NSUnicodeStringEncoding]];
	
    [parser setDelegate:self];
    [parser setShouldProcessNamespaces:NO]; // We don't care about namespaces
    [parser setShouldReportNamespacePrefixes:NO]; //
    [parser setShouldResolveExternalEntities:NO]; // We just want data, no other stuff
	
	// NSLog(@"About to parse.");
    [parser parse]; // Parse the data
	
	
    if ([parser parserError])
	{
		NSLog([parser parserError].localizedDescription);
		
		// finish up
		fullDeckFailureFlag = YES; // log failure so that user may be notified of it after end of current sync / download
		[parser release];
		[self completeDownloadAfterSuccess:NO];
    }
	else
	{
		// finish up
		[parser release];
		[self completeDownloadAfterSuccess:YES];	
	}
}

- (void) parserDidStartDocument:(NSXMLParser *)parserDidStartDocument
{
	//NSLog(@"Started parsing XML document");
	inCardsDefinition = NO;
	
	// open transaction
	sqlite3_exec([VariableStore sharedInstance].database, "BEGIN", 0, 0, 0);
}

- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parserError
{
	NSString *errorString = [NSString stringWithFormat:@"Parser error, error code %i", [parserError code]];
	NSLog(errorString);
	
	UIAlertView *errorAlert = [[UIAlertView alloc] initWithTitle:@"Error loading downloaded deck" message:errorString delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil];
	[errorAlert show];	
}

- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict
{
	// For all elements....
	currentText = @""; // reset the current Text value ready for any new text node
	
	// for specific elements....
	
	// For cards, create a new cards row in the DB
	if ([elementName isEqualToString:@"Cards"])
	{
		// Log that we're about to receive information on the cards in the deck
		inCardsDefinition = YES;
		currentCardPosition = 0; // will be incremented to 1 for the first card		
	}
	
	// Nodes other than Deck and Cards are only interesting if we're inside a Cards block (otherwise it's template information)
	if (inCardsDefinition)
	{
		if ([elementName isEqualToString:@"Card"])
		{
			currentCardPosition++;
			currentSidePosition = 0; // will be incremented to 1 before addition of 1st side
			// insert a Card row into the db to represent the incoming card
			const char *sql = "INSERT INTO Card(deck_id, orig_position, position, known) VALUES(?,?,?,?)";
			if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sql, -1, &addStmt, NULL) != SQLITE_OK)
			{
				NSLog(@"Error while creating Card INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			sqlite3_bind_int(addStmt, 1, deckID);
			sqlite3_bind_int(addStmt, 2, currentCardPosition);
			sqlite3_bind_int(addStmt, 3, currentCardPosition);
			sqlite3_bind_int(addStmt, 4, 0);
			
			if(SQLITE_DONE != sqlite3_step(addStmt))
			{
				NSLog(@"Error running Card INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			else
			{
				// store the autoincremented primary key to reference from future inserts
				cardID = sqlite3_last_insert_rowid([VariableStore sharedInstance].database);
			}
			addStmt = nil;
		}
		
		if ([elementName isEqualToString:@"Side"])
		{
			currentSidePosition++;
			currentComponentPosition = 0;
			
			// retrieve attribute values from XML
			int sideBackgroundColor = [[attributeDict valueForKey:@"backgroundColor"] intValue];
			
			// insert a Side row into the db to represent the incoming Side
			const char *sql = "INSERT INTO Side(card_id, position, background_color) VALUES(?,?,?)";
			if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sql, -1, &addStmt, NULL) != SQLITE_OK)
			{
				NSLog(@"Error while creating Side INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			sqlite3_bind_int(addStmt, 1, cardID);
			sqlite3_bind_int(addStmt, 2, currentSidePosition);
			sqlite3_bind_int(addStmt, 3, sideBackgroundColor);
			
			
			if(SQLITE_DONE != sqlite3_step(addStmt))
			{
				NSLog(@"Error running Side INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			else
			{
				// store the autoincremented primary key to reference from future inserts
				sideID = sqlite3_last_insert_rowid([VariableStore sharedInstance].database);
			}
			addStmt = nil;
		}
		
		if ([elementName isEqualToString:@"Component"])
		{
			// increment the component position, ready for the new component
			currentComponentPosition++;
			
			// retrieve attribute values from XML
			int x = [[attributeDict valueForKey:@"x"] intValue];
			int y = [[attributeDict valueForKey:@"y"] intValue];
			int width = [[attributeDict valueForKey:@"width"] intValue];
			int height = [[attributeDict valueForKey:@"height"] intValue];
			
			// insert a Component row into the db to represent the incoming Component
			const char *sql = "INSERT INTO Component(side_id, display_order,x,y,width,height,type) VALUES(?,?,?,?,?,?,?)";
			if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sql, -1, &addStmt, NULL) != SQLITE_OK)
			{
				NSLog(@"Error while creating Component INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			sqlite3_bind_int(addStmt, 1, sideID);
			sqlite3_bind_int(addStmt, 2, currentComponentPosition);
			sqlite3_bind_int(addStmt, 3, x);
			sqlite3_bind_int(addStmt, 4, y);
			sqlite3_bind_int(addStmt, 5, width);
			sqlite3_bind_int(addStmt, 6, height);
			sqlite3_bind_int(addStmt, 7, 1); // !!!!! TYPE TEMPORARILY HARDCODED TO 1 - TYPE TO LATER BE REMOVED 
			
			if(SQLITE_DONE != sqlite3_step(addStmt))
			{
				NSLog(@"Error running Card INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			else
			{
				// store the autoincremented primary key to reference from future inserts
				componentID = sqlite3_last_insert_rowid([VariableStore sharedInstance].database);
			}
			addStmt = nil;
		}		
	}
	
}

- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName
{
	//NSLog(@"Ended this element: %@", elementName);
	
	if ([elementName isEqualToString:@"Cards"])
	{
		inCardsDefinition = NO;
	}
	
	if ([elementName isEqualToString:@"Deck"])
	{
		// parsing has finished
		// update database to show that deck is fully loaded
		sqlite3_stmt *stmt = nil;
		if(stmt == nil)
		{
			const char *updateSQL = "UPDATE Deck SET fully_downloaded = 1 WHERE id = ?";
			if(sqlite3_prepare_v2([VariableStore sharedInstance].database, updateSQL, -1, &stmt, NULL) != SQLITE_OK)
				NSLog(@"Error while creating update statement: '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
		}
		else
		{
			NSLog(@"Error: stmt not nil");
		}
		
		sqlite3_bind_int(stmt, 1, deckID);
		
		if(SQLITE_DONE != sqlite3_step(stmt))
		{NSAssert1(0, @"Error while setting deck to fully_downloaded in DB: '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));}
		sqlite3_reset(stmt);
		stmt = nil;
	}
	
	// Nodes other than Deck and Cards are only interesting if we're inside a Cards block (otherwise it's template information)
	if (inCardsDefinition)
	{
		// TextBox row must be added to the DB only when we encounter the closing tag: we need the data from its child attributes first
		if ([elementName isEqualToString:@"TextBox"])
		{
			// insert a TextBox row into the db to represent the incoming TextBox
			const char *sql = "INSERT INTO TextBox(component_id, text, font_id, font_size, foreground_color, foreground_alpha, background_color, background_alpha, alignment_id, background_transparent) VALUES(?,?,?,?,?,?,?,?,?,?)";
			if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sql, -1, &addStmt, NULL) != SQLITE_OK)
			{
				NSLog(@"Error while creating TextBox INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			sqlite3_bind_int(addStmt, 1, componentID);
			sqlite3_bind_text(addStmt, 2, [text UTF8String], -1, SQLITE_TRANSIENT);
			sqlite3_bind_double(addStmt, 3, fontID);
			sqlite3_bind_double(addStmt, 4, fontSize);
			sqlite3_bind_double(addStmt, 5, foregroundColor);
			sqlite3_bind_double(addStmt, 6, foregroundAlpha);
			sqlite3_bind_double(addStmt, 7, backgroundColor);
			sqlite3_bind_double(addStmt, 8, backgroundAlpha);
			sqlite3_bind_int(addStmt, 9, alignmentID);
			sqlite3_bind_int(addStmt, 10, backgroundTransparent);
			
			if(SQLITE_DONE != sqlite3_step(addStmt))
			{
				NSLog(@"Error running TextBox INSERT statement. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
			}
			
			addStmt = nil;
			
			// clean up variables so malformed XML is more likely to be caught
			text = @"";
			fontID = 0;
			fontSize = 0;
			foregroundColor = 0;
			backgroundColor = 0;
			alignmentID = 0 ;
		}
		
		if ([elementName isEqualToString:@"text"])
		{
			[text release];
			text = [currentText copy];
		}
		
		if ([elementName isEqualToString:@"font"])
		{
			if ([currentText isEqualToString:@"Arial"])
			{fontID = 1;}
		}
		
		if ([elementName isEqualToString:@"fontSize"])
		{
			fontSize = [currentText floatValue];
		}
		
		if ([elementName isEqualToString:@"foregroundColor"])
		{
			foregroundColor = [currentText intValue];
		}		
		
		if ([elementName isEqualToString:@"backgroundColor"])
		{
			backgroundColor = [currentText intValue];
		}		

		if ([elementName isEqualToString:@"backgroundTransparent"])
		{
			BOOL bgTransparentBoolValue = [currentText boolValue];
			if (bgTransparentBoolValue == YES)
				{backgroundTransparent = 1;}
			else
				{backgroundTransparent = 0;}
		}				
		
		if ([elementName isEqualToString:@"alpha"])
		{
			foregroundAlpha = [currentText floatValue];
			backgroundAlpha = foregroundAlpha;
		}
		
		if ([elementName isEqualToString:@"alignment"])
		{
			if([currentText isEqualToString:@"left"])
			{alignmentID = 1;}
			if([currentText isEqualToString:@"center"])
			{alignmentID = 2;}
			if([currentText isEqualToString:@"right"])
			{alignmentID = 3;}
		}
		
	}
	
}

- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string
{
	currentText = [currentText stringByAppendingString:string];	
}

#pragma mark -
#pragma mark Clean Up & Completion Methods

-(void)cleanPartiallyDownloadedDeckInDBUsingDeckID:(int)aDeckID
{
	// remove deck row from DB
	static sqlite3_stmt *deleteStmt = nil;
	NSString *deletionString = [NSString stringWithFormat:@"DELETE FROM Card WHERE deck_id = %d", aDeckID];
	if(deleteStmt == nil)
	{
		const char *sql = [deletionString UTF8String];
		if(sqlite3_prepare_v2([VariableStore sharedInstance].database, sql, -1, &deleteStmt, NULL) != SQLITE_OK)
		{
			NSLog(@"Error while creating delete statement while cleaning up partially downloaded deck. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
		}
	}
	
	if (SQLITE_DONE != sqlite3_step(deleteStmt))
		NSLog(@"Error while deleting while cleaning up partically downloaded deck. '%s'", sqlite3_errmsg([VariableStore sharedInstance].database));
	
	sqlite3_reset(deleteStmt);
	deleteStmt = nil;
}

// Must be called at the end of any parsing process - regardless of the result
- (void)completeDownloadAfterSuccess:(BOOL)success
{
	// complete the transaction
	sqlite3_exec([VariableStore sharedInstance].database, "COMMIT", 0, 0, 0);
	
	// refresh the library
	[[MyDecksViewController sharedInstance] refreshTable];

	// unlock the object to allow downloads to go ahead
	locked = NO;
	
	// if there are any downloads waiting, start the oldest now
	if ([downloadQueue count] > 0)
	{
		DeckDownloaderQueueItem *nextItem = [downloadQueue objectAtIndex:0];
		[downloadQueue removeObjectAtIndex:0];
		// If there is already metadata in the DB for this queue item, complete its download
		if ([nextItem metadataAlreadyExists])
		{
			[self completeDownloadOfDeckID:[nextItem userVisibleID] withIPhoneDeckID:[nextItem iPhoneDeckID]];
		}
		else // otherwise, download the metadata first and then go on to complete it
		{
			[self downloadDeckID:[nextItem userVisibleID]];
		}		
	}
	else // if there are no downloads queued, then any sync that was in progress has finished
	{
		// if there was sucess, and there are any broken downloads remaining, process those too
		if (success && ([DeckDownloader areBrokenDownloads]))
		{
			fullDeckFailureFlag = NO; // we're about to have another stab at them, so set flag to NO - it will be set back to YES again if necessary
			[self resumeBrokenDownloadswithUserRequested:NO];
		}
		
		// if there were any decks processed that had metadata downloaded but were not fully downloaded and parsed, notify the user
		if (fullDeckFailureFlag)
		{
			UIAlertView *errorAlert;

			if (isAResumeRequestAndNotYetReachedShuffleDuck)
			{
				errorAlert = [[UIAlertView alloc]
							   initWithTitle:  [NSString stringWithFormat:@"Couldn't reach ShuffleDuck"]
							   message: [NSString stringWithFormat:@"Please check your network connection and try again."]
							   delegate: nil
							   cancelButtonTitle: @"OK"
							   otherButtonTitles: nil];
			}
			else
			{
				errorAlert =  [[UIAlertView alloc]
							   initWithTitle: @"Download interrupted"
							   message: @"Please check your network connection and tap an incomplete Deck to resume."
							   delegate: nil
							   cancelButtonTitle: @"OK"
							   otherButtonTitles: nil];
			}
			[errorAlert show];
			[errorAlert release];
		}
		
		// reset status flags
		isAResumeRequestAndNotYetReachedShuffleDuck = NO;
		fullDeckFailureFlag = NO;
		
		// re-enable the sync button and stop showing busy indicator
		[MyDecksViewController sharedInstance].syncButton.enabled = YES;
		[[MyDecksViewController sharedInstance] hideMessages];
		[ProgressViewController stopShowingProgress];
	}
}

- (void)dealloc {
	if(addStmt) sqlite3_finalize(addStmt);
    [super dealloc];
}

@end
